(defun higher (cmp a b)
  (if (funcall cmp a b)
      t
      nil))
(defun last-root (len)
  (floor (/ (- len 2) 2)))
(defun parent (idx)
  (floor (/ idx 2)))
(defun left-child (idx)
  (* 2 idx))
(defun right-child (idx)
  (+ (* 2 idx) 1))
(defmacro while (form &body body)
  `(do ()
       ((not ,form))
     ,@body))
(defun heap-len (heap)
  (svref heap 0))
(defun heap-setvalue (heap idx v)
  (setf (svref heap idx) v))
(defun heap-setlen (heap len)
  (heap-setvalue heap 0 len))
(defun heapify-down->up (heap idx &key cmp)
  (do ()
      (nil)
    (let ((p (parent idx)))
      (if (and (> p 0)
	       (not (higher cmp (svref heap p) (svref heap idx))))
	  (progn
	    (rotatef (svref heap p)
		     (svref heap idx))
	    (setf idx p))
	  (return-from heapify-down->up nil)))))

(defun heap-add (heap var &key cmp)
  (let* ((heaplen (heap-len heap)))
    (incf heaplen)
    (heap-setlen heap heaplen)
    (heap-setvalue heap heaplen var)
    (heapify-down->up heap heaplen :cmp cmp)))

(defun heap-outof (heap idx)
  (if (and (> idx 0)
	   (< idx (heap-len heap)))
      nil
      t))
(defun heapify-up->down (heap idx &key cmp)
  (do ()
      (nil)
    (let ((lc (left-child idx))
	  (rc (right-child idx))
	  (highest-idx idx))
      (if (heap-outof heap lc)
	  (return-from heapify-up->down nil)
	  (if (higher cmp (svref heap lc) (svref heap idx))
	      (setf highest-idx lc)))
      (if (and (not (heap-outof heap rc))
	       (higher cmp (svref heap rc) (svref heap idx)))
	  (setf highest-idx rc))
      (if (not (eql highest-idx idx))
	  (progn
	    (rotatef (svref heap highest-idx)
		     (svref heap idx))
	    (setf idx highest-idx))
	  (return-from heapify-up->down nil)))))
	    
(defun heap-remove (heap idx &key cmp)
  (rotatef (svref heap (heap-len heap))
	   (svref heap idx))
  (heap-setlen heap (- (heap-len heap) 1))
  (if (or (heap-outof heap (parent idx))
	  (higher cmp (svref heap (parent idx)) (svref heap idx)))
      (heapify-up->down heap idx :cmp cmp)
      (heapify-down->up heap idx :cmp cmp)))

(defun heap-pop (heap &key cmp)
  (heap-remove heap 1 :cmp cmp))
  
(defun make-heap (vec &key (cmp #'<))
  (let ((heap (make-array (+ 1 (length vec)) :initial-element nil)))
    (heap-setlen heap 0)
    (dolist (var vec)
      (heap-add heap var :cmp cmp))
    heap))


